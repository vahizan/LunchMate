name: FindMyLunch CI/CD

# Purpose: This unified workflow handles the complete CI/CD pipeline for the FindMyLunch application.
# It replaces the separate frontend.yml and backend.yml workflows with a single, comprehensive workflow.
#
# Key Features:
# - Unified testing and building for both frontend and backend components
# - CloudFormation-based infrastructure deployment
# - Multi-environment support (QA and Production)
# - Component-specific deployment options
#
# CloudFormation Deployment:
# - Uses nested templates (master.yaml, frontend.yaml, backend.yaml, networking.yaml, database.yaml)
# - Templates are uploaded to environment-specific S3 buckets
# - Infrastructure is created/updated based on environment parameters
#
# Deployment Environments:
# - QA: Automatic deployment on push to main branch
# - Production: Requires manual approval via environment protection rules
#
# Triggering Specific Deployments:
# - Automatic: Push to main branch triggers tests and QA deployment
# - Manual: Use workflow_dispatch with environment (qa/prod) and component (all/frontend/backend) options
# - Production deployments require approval via the GitHub environment protection rules

on:
  push:
    branches: [ main ]
    paths:
      - 'client/**'
      - 'server/**'
      - 'shared/**'
      - '.github/workflows/ci-cd.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'client/**'
      - 'server/**'
      - 'shared/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'qa'
        type: choice
        options:
          - qa
          - prod
      component:
        description: 'Component to deploy'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - frontend
          - backend

jobs:
   test-frontend:
    name: Test Frontend
    runs-on: ubuntu-latest
    strategy:
      matrix:
        component: [frontend]
        version: [20]
    if: |
      github.event_name != 'workflow_dispatch' ||
      github.event.inputs.component == 'all' ||
      github.event.inputs.component == 'frontend'
    steps:
       - name: Checkout code
         uses: actions/checkout@v4

       - name: Setup Node.js
         uses: actions/setup-node@v4
         with:
          node-version: '${{ matrix.version }}'
          cache: 'npm'

       - name: Install dependencies
         run: npm ci

       - name: Run tests
         run: npm test -- client/src

   test-backend:
    name: Test Backend
    runs-on: ubuntu-latest
    strategy:
      matrix:
        component: [backend]
        version: [20]
    if: |
      github.event_name != 'workflow_dispatch' ||
      github.event.inputs.component == 'all' ||
      github.event.inputs.component == 'backend'
    steps:
       - name: Checkout code
         uses: actions/checkout@v4

       - name: Setup Node.js
         uses: actions/setup-node@v4
         with:
          node-version: '${{ matrix.version }}'
          cache: 'npm'

       - name: Install dependencies
         run: npm ci

       - name: Run tests
         run: npm test -- server/lib/__tests__

   build:
    name: Build
    needs: [test-frontend, test-backend]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        component: [frontend, backend]
        version: [20]
        include:
          - component: frontend
            artifact_name: frontend-build
            artifact_path: dist/client
          - component: backend
            artifact_name: backend-build
            artifact_path: eb-bundle.zip
    if: |
      github.event_name == 'push' ||
      github.event_name == 'pull_request' ||
      (github.event_name == 'workflow_dispatch' &&
       (github.event.inputs.component == 'all' || github.event.inputs.component == 'frontend' || github.event.inputs.component == 'backend'))
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '${{matrix.version}}'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build frontend
        if: matrix.component == 'frontend'
        run: npm run build:frontend
        env:
          NODE_ENV: prod

      - name: Build backend
        if: matrix.component == 'backend'
        run: |
          npm run build:backend
          # Create Elastic Beanstalk bundle
          mkdir -p eb-bundle
          cp -r dist/* eb-bundle/
          cp package.json package-lock.json eb-bundle/
          cd eb-bundle
          zip -r ../eb-bundle.zip .
        env:
          NODE_ENV: prod

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: ${{ matrix.artifact_path }}
          retention-days: 7

   # Common setup job for CloudFormation deployment
   setup-cloudformation:
     name: Setup CloudFormation Deployment
     needs: build
     if: |
       github.event_name == 'push' ||
       github.event_name == 'pull_request' ||
       (github.event_name == 'workflow_dispatch' &&
        (github.event.inputs.component == 'all'))
     runs-on: ubuntu-latest
     environment: ${{ github.event.inputs.environment || 'qa' }}
     outputs:
       env: ${{ steps.set-env.outputs.env }}
       bucket_name: ${{ steps.set-env.outputs.bucket_name }}
     steps:
       - name: Checkout code
         uses: actions/checkout@v4

       - name: Configure AWS credentials
         uses: aws-actions/configure-aws-credentials@v4
         with:
           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
           aws-region: ${{ vars.AWS_REGION }}

       - name: Set environment variables
         id: set-env
         run: |
           ENV="${{ github.event.inputs.environment || 'qa' }}"
           BUCKET_NAME="findmylunch-artifacts-${ENV}-${{ vars.AWS_REGION }}"
           echo "env=$ENV" >> $GITHUB_OUTPUT
           echo "bucket_name=$BUCKET_NAME" >> $GITHUB_OUTPUT

       - name: Create S3 bucket for CloudFormation templates if it doesn't exist
         run: |
           BUCKET_NAME="${{ steps.set-env.outputs.bucket_name }}"
           
           if ! aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
             aws s3 mb "s3://$BUCKET_NAME" --region ${{ vars.AWS_REGION }}
             aws s3api put-bucket-versioning --bucket "$BUCKET_NAME" --versioning-configuration Status=Enabled
           fi

       - name: Upload CloudFormation templates to S3
         run: |
           BUCKET_NAME="${{ steps.set-env.outputs.bucket_name }}"
           
           # Create templates directory in S3 bucket
           aws s3api put-object --bucket "$BUCKET_NAME" --key "templates/"
           
           # Upload templates
           aws s3 cp master.yaml "s3://$BUCKET_NAME/templates/"
           aws s3 cp backend.yaml "s3://$BUCKET_NAME/templates/"
           aws s3 cp frontend.yaml "s3://$BUCKET_NAME/templates/"
           aws s3 cp networking.yaml "s3://$BUCKET_NAME/templates/"
           aws s3 cp database.yaml "s3://$BUCKET_NAME/templates/"
           aws s3 cp api-certificate.yaml "s3://$BUCKET_NAME/templates/"
           
           # Create us-east-1 bucket for API Gateway certificate if it doesn't exist
           ENV="${{ steps.set-env.outputs.env }}"
           US_EAST_BUCKET_NAME="findmylunch-artifacts-${ENV}-us-east-1"
           
           # Configure AWS credentials for us-east-1
           aws configure set region us-east-1
           
           if ! aws s3api head-bucket --bucket "$US_EAST_BUCKET_NAME" 2>/dev/null; then
             aws s3 mb "s3://$US_EAST_BUCKET_NAME" --region us-east-1
             aws s3api put-bucket-versioning --bucket "$US_EAST_BUCKET_NAME" --versioning-configuration Status=Enabled
           fi
           
           # Create templates directory in us-east-1 S3 bucket
           aws s3api put-object --bucket "$US_EAST_BUCKET_NAME" --key "templates/"
           
           # Upload API certificate template to us-east-1 bucket
           aws s3 cp api-certificate.yaml "s3://$US_EAST_BUCKET_NAME/templates/"
           
           # Reset region to original
           aws configure set region ${{ vars.AWS_REGION }}

   # Deploy networking stack first to create the hosted zone
   deploy-networking:
     name: Deploy Networking Stack
     needs: [setup-cloudformation]
     runs-on: ubuntu-latest
     environment: ${{ github.event.inputs.environment || 'qa' }}
     steps:
       - name: Checkout code
         uses: actions/checkout@v4

       - name: Configure AWS credentials
         uses: aws-actions/configure-aws-credentials@v4
         with:
           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
           aws-region: ${{ vars.AWS_REGION }}

       - name: Deploy Networking Stack
         run: |
           ENV="${{ needs.setup-cloudformation.outputs.env }}"
           BUCKET_NAME="${{ needs.setup-cloudformation.outputs.bucket_name }}"
           STACK_NAME="findmylunch-${ENV}-networking"
           PARAMS_FILE="${ENV}-parameters.json"
           
           # Extract networking parameters from the main parameters file
           jq '[.[] | select(.ParameterKey | test("^(EnvironmentName|DomainName|SubDomainPrefix|VpcCIDR|PublicSubnet1CIDR|PublicSubnet2CIDR|PrivateSubnet1CIDR|PrivateSubnet2CIDR)$"))]' $PARAMS_FILE > networking-params.json
           
           # Check if stack exists
           if aws cloudformation describe-stacks --stack-name "$STACK_NAME" 2>/dev/null; then
             # Update existing stack
             aws cloudformation update-stack \
               --stack-name "$STACK_NAME" \
               --template-url "https://${BUCKET_NAME}.s3.amazonaws.com/templates/networking.yaml" \
               --parameters file://networking-params.json \
               --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM
           else
             # Create new stack
             aws cloudformation create-stack \
               --stack-name "$STACK_NAME" \
               --template-url "https://${BUCKET_NAME}.s3.amazonaws.com/templates/networking.yaml" \
               --parameters file://networking-params.json \
               --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM
           fi
           
           # Wait for stack creation/update to complete
           aws cloudformation wait stack-create-complete --stack-name "$STACK_NAME" || \
           aws cloudformation wait stack-update-complete --stack-name "$STACK_NAME"
           
           # Verify SSL certificate validation status
           echo "Checking SSL certificate validation status..."
           CERT_ARN=$(aws cloudformation describe-stacks \
             --stack-name "$STACK_NAME" \
             --query "Stacks[0].Outputs[?OutputKey=='CertificateArn'].OutputValue" \
             --output text)
             
           if [ -n "$CERT_ARN" ]; then
             VALIDATION_STATUS=$(aws acm describe-certificate \
               --certificate-arn "$CERT_ARN" \
               --query "Certificate.Status" \
               --output text)
               
             echo "Certificate validation status: $VALIDATION_STATUS"
             
             if [ "$VALIDATION_STATUS" != "ISSUED" ]; then
               echo "Certificate is not yet validated. You may need to add DNS validation records."
               aws acm describe-certificate \
                 --certificate-arn "$CERT_ARN" \
                 --query "Certificate.DomainValidationOptions[].ResourceRecord" \
                 --output json
             fi
           fi
           
  # Deploy API Gateway Certificate stack in us-east-1 after networking
   deploy-api-certificate:
     name: Deploy API Gateway Certificate Stack
     needs: [setup-cloudformation,deploy-networking]
     runs-on: ubuntu-latest
     environment: ${{ github.event.inputs.environment || 'qa' }}
     steps:
       - name: Checkout code
         uses: actions/checkout@v4

       - name: Configure AWS credentials for us-east-1
         uses: aws-actions/configure-aws-credentials@v4
         with:
           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
           aws-region: us-east-1

       - name: Get Hosted Zone ID from Networking Stack
         run: |
           ENV="${{ needs.setup-cloudformation.outputs.env }}"
           # Configure AWS credentials for main region to get the hosted zone ID
           aws configure set region ${{ vars.AWS_REGION }}
           
           # Get the hosted zone ID from the networking stack
           HOSTED_ZONE_ID=$(aws cloudformation describe-stacks \
             --stack-name "findmylunch-${ENV}-networking" \
             --query "Stacks[0].Outputs[?OutputKey=='HostedZoneId'].OutputValue" \
             --output text)
           
           echo "HOSTED_ZONE_ID=$HOSTED_ZONE_ID" >> $GITHUB_ENV
           
           # Reset region to us-east-1 for certificate creation
           aws configure set region us-east-1

       - name: Deploy API Certificate Stack
         run: |
           ENV="${{ needs.setup-cloudformation.outputs.env }}"
           BUCKET_NAME="findmylunch-artifacts-${ENV}-us-east-1"
           STACK_NAME="findmylunch-${ENV}-api-certificate"
           PARAMS_FILE="${ENV}-parameters.json"
           
           # Extract certificate parameters from the main parameters file (excluding HostedZoneId)
           jq '[.[] | select(.ParameterKey | test("^(EnvironmentName|DomainName|SubDomainPrefix)$"))]' $PARAMS_FILE > certificate-params.json
           
           # Add the HostedZoneId from the networking stack
           jq '. += [{"ParameterKey": "HostedZoneId", "ParameterValue": "'"$HOSTED_ZONE_ID"'"}]' certificate-params.json > certificate-params-temp.json
           mv certificate-params-temp.json certificate-params.json
           
           # Check if stack exists
           if aws cloudformation describe-stacks --stack-name "$STACK_NAME" 2>/dev/null; then
             # Update existing stack
             aws cloudformation update-stack \
               --stack-name "$STACK_NAME" \
               --template-url "https://${BUCKET_NAME}.s3.amazonaws.com/templates/api-certificate.yaml" \
               --parameters file://certificate-params.json \
               --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM
           else
             # Create new stack
             aws cloudformation create-stack \
               --stack-name "$STACK_NAME" \
               --template-url "https://${BUCKET_NAME}.s3.amazonaws.com/templates/api-certificate.yaml" \
               --parameters file://certificate-params.json \
               --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM
           fi
           
           # Wait for stack creation/update to complete
           aws cloudformation wait stack-create-complete --stack-name "$STACK_NAME" || \
           aws cloudformation wait stack-update-complete --stack-name "$STACK_NAME"
           
           # Verify certificate validation status
           echo "Checking certificate validation status..."
           CERT_ARN=$(aws cloudformation describe-stacks \
             --stack-name "$STACK_NAME" \
             --query "Stacks[0].Outputs[?OutputKey=='ApiGatewayCertificateArn'].OutputValue" \
             --output text)
             
           if [ -n "$CERT_ARN" ]; then
             VALIDATION_STATUS=$(aws acm describe-certificate \
               --certificate-arn "$CERT_ARN" \
               --query "Certificate.Status" \
               --output text)
               
             echo "Certificate validation status: $VALIDATION_STATUS"
             
             if [ "$VALIDATION_STATUS" != "ISSUED" ]; then
               echo "Certificate is not yet validated. You may need to add DNS validation records."
               aws acm describe-certificate \
                 --certificate-arn "$CERT_ARN" \
                 --query "Certificate.DomainValidationOptions[].ResourceRecord" \
                 --output json
             fi
           fi         

   # Deploy database stack after networking
   deploy-database:
     name: Deploy Database Stack
     needs: [setup-cloudformation, deploy-networking, deploy-api-certificate]
     runs-on: ubuntu-latest
     environment: ${{ github.event.inputs.environment || 'qa' }}
     steps:
       - name: Checkout code
         uses: actions/checkout@v4

       - name: Configure AWS credentials
         uses: aws-actions/configure-aws-credentials@v4
         with:
           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
           aws-region: ${{ vars.AWS_REGION }}

       - name: Deploy Database Stack
         run: |
           ENV="${{ needs.setup-cloudformation.outputs.env }}"
           BUCKET_NAME="${{ needs.setup-cloudformation.outputs.bucket_name }}"
           STACK_NAME="findmylunch-${ENV}-database"
           PARAMS_FILE="${ENV}-parameters.json"
           
           # Extract database parameters from the main parameters file
           jq '[.[] | select(.ParameterKey | test("^(EnvironmentName|DBInstanceClass|DBName|DBUsername|DBAllocatedStorage|DBMaxAllocatedStorage|DBBackupRetentionPeriod|DBEngineVersion|EnablePerformanceInsights|EnableEnhancedMonitoring|MonitoringInterval|ArtifactBucketPrefix)$"))]' $PARAMS_FILE > database-params.json
           
           # Check if stack exists
           if aws cloudformation describe-stacks --stack-name "$STACK_NAME" 2>/dev/null; then
             # Update existing stack
             aws cloudformation update-stack \
               --stack-name "$STACK_NAME" \
               --template-url "https://${BUCKET_NAME}.s3.amazonaws.com/templates/database.yaml" \
               --parameters file://database-params.json \
               --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM
           else
             # Create new stack
             aws cloudformation create-stack \
               --stack-name "$STACK_NAME" \
               --template-url "https://${BUCKET_NAME}.s3.amazonaws.com/templates/database.yaml" \
               --parameters file://database-params.json \
               --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM
           fi
           
           # Wait for stack creation/update to complete
           aws cloudformation wait stack-create-complete --stack-name "$STACK_NAME" || \
           aws cloudformation wait stack-update-complete --stack-name "$STACK_NAME"

   # Deploy backend stack after database
   deploy-backend:
     name: Deploy Backend Stack
     needs: [setup-cloudformation, deploy-networking, deploy-database, deploy-api-certificate]
     runs-on: ubuntu-latest
     environment: ${{ github.event.inputs.environment || 'qa' }}
     steps:
       - name: Checkout code
         uses: actions/checkout@v4

       - name: Configure AWS credentials
         uses: aws-actions/configure-aws-credentials@v4
         with:
           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
           aws-region: ${{ vars.AWS_REGION }}

       - name: Deploy Backend Stack
         run: |
           ENV="${{ needs.setup-cloudformation.outputs.env }}"
           BUCKET_NAME="${{ needs.setup-cloudformation.outputs.bucket_name }}"
           STACK_NAME="findmylunch-${ENV}-backend"
           PARAMS_FILE="${ENV}-parameters.json"
           
           # Extract backend parameters from the main parameters file
           jq '[.[] | select(.ParameterKey | test("^(EnvironmentName|ArtifactBucketPrefix|ApplicationName|EnvironmentNamePrefix|DomainName|SubDomainPrefix|NodeJSVersion|InstanceType|MinInstances|MaxInstances|ScaleUpThreshold|ScaleDownThreshold|SSLCertificateARN|HostedZoneId)$"))]' $PARAMS_FILE > backend-params.json
           
           # Create SecretsManagerARN parameter
           SECRETS_MANAGER_ARN=$(aws cloudformation describe-stacks \
             --stack-name "findmylunch-${ENV}" \
             --query "Stacks[0].Outputs[?OutputKey=='SecretsManagerARN'].OutputValue" \
             --output text 2>/dev/null || echo "")
           
           if [ -z "$SECRETS_MANAGER_ARN" ]; then
             # If not found, create a new secret
             SECRETS_MANAGER_ARN=$(aws secretsmanager create-secret \
               --name "${ENV}-findmylunch-env-vars" \
               --description "Environment variables for ${ENV} FindMyLunch application" \
               --secret-string '{}' \
               --query ARN --output text)
           fi
           
           # Add SecretsManagerARN to backend parameters
           jq '. += [{"ParameterKey": "SecretsManagerARN", "ParameterValue": "'"$SECRETS_MANAGER_ARN"'"}]' backend-params.json > backend-params-temp.json
           mv backend-params-temp.json backend-params.json
           
           # Configure AWS credentials for us-east-1 to get the API Gateway certificate ARN
           aws configure set region us-east-1
           
           # Add ApiGatewayCertificateARN from the API certificate stack in us-east-1
           API_CERT_ARN=$(aws cloudformation describe-stacks \
             --stack-name "findmylunch-${ENV}-api-certificate" \
             --query "Stacks[0].Outputs[?OutputKey=='ApiGatewayCertificateArn'].OutputValue" \
             --output text 2>/dev/null || echo "")
           
           # Reset region to original
           aws configure set region ${{ vars.AWS_REGION }}
           
           if [ -n "$API_CERT_ARN" ]; then
             jq '. += [{"ParameterKey": "ApiGatewayCertificateARN", "ParameterValue": "'"$API_CERT_ARN"'"}]' backend-params.json > backend-params-temp.json
             mv backend-params-temp.json backend-params.json
           else
             echo "WARNING: API Gateway Certificate ARN not found in us-east-1 region"
             echo "This may cause deployment failures if the certificate is required"
           fi
           
           # Check if stack exists
           if aws cloudformation describe-stacks --stack-name "$STACK_NAME" 2>/dev/null; then
             # Update existing stack
             aws cloudformation update-stack \
               --stack-name "$STACK_NAME" \
               --template-url "https://${BUCKET_NAME}.s3.amazonaws.com/templates/backend.yaml" \
               --parameters file://backend-params.json \
               --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM
           else
             # Create new stack
             aws cloudformation create-stack \
               --stack-name "$STACK_NAME" \
               --template-url "https://${BUCKET_NAME}.s3.amazonaws.com/templates/backend.yaml" \
               --parameters file://backend-params.json \
               --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM
           fi
           
           # Wait for stack creation/update to complete
           aws cloudformation wait stack-create-complete --stack-name "$STACK_NAME" || \
           aws cloudformation wait stack-update-complete --stack-name "$STACK_NAME"

   # Deploy frontend stack last
   deploy-frontend:
     name: Deploy Frontend Stack
     needs: [setup-cloudformation, deploy-networking, deploy-backend]
     runs-on: ubuntu-latest
     environment: ${{ github.event.inputs.environment || 'qa' }}
     steps:
       - name: Checkout code
         uses: actions/checkout@v4

       - name: Configure AWS credentials
         uses: aws-actions/configure-aws-credentials@v4
         with:
           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
           aws-region: ${{ vars.AWS_REGION }}

       - name: Deploy Frontend Stack
         run: |
           ENV="${{ needs.setup-cloudformation.outputs.env }}"
           BUCKET_NAME="${{ needs.setup-cloudformation.outputs.bucket_name }}"
           STACK_NAME="findmylunch-${ENV}-frontend"
           PARAMS_FILE="${ENV}-parameters.json"
           
           # Extract frontend parameters from the main parameters file
           jq '[.[] | select(.ParameterKey | test("^(EnvironmentName|DomainName|SubDomainPrefix|CreateRoute53Records|HostedZoneId)$"))]' $PARAMS_FILE > frontend-params.json
           
           # Add CertificateArn from networking stack
           CERT_ARN=$(aws cloudformation describe-stacks \
             --stack-name "findmylunch-${ENV}-networking" \
             --query "Stacks[0].Outputs[?OutputKey=='CertificateArn'].OutputValue" \
             --output text 2>/dev/null || echo "")
           
           if [ -n "$CERT_ARN" ]; then
             jq '. += [{"ParameterKey": "CertificateArn", "ParameterValue": "'"$CERT_ARN"'"}]' frontend-params.json > frontend-params-temp.json
             mv frontend-params-temp.json frontend-params.json
           fi
           
           # Check if stack exists
           if aws cloudformation describe-stacks --stack-name "$STACK_NAME" 2>/dev/null; then
             # Update existing stack
             aws cloudformation update-stack \
               --stack-name "$STACK_NAME" \
               --template-url "https://${BUCKET_NAME}.s3.amazonaws.com/templates/frontend.yaml" \
               --parameters file://frontend-params.json \
               --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM
           else
             # Create new stack
             aws cloudformation create-stack \
               --stack-name "$STACK_NAME" \
               --template-url "https://${BUCKET_NAME}.s3.amazonaws.com/templates/frontend.yaml" \
               --parameters file://frontend-params.json \
               --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM
           fi
           
           # Wait for stack creation/update to complete
           aws cloudformation wait stack-create-complete --stack-name "$STACK_NAME" || \
           aws cloudformation wait stack-update-complete --stack-name "$STACK_NAME"

   deploy-qa:
    name: Deploy to QA (skipped unless the app grows)
    needs: build
    if: false
    runs-on: ubuntu-latest
    environment: qa
    strategy:
      matrix:
        component: [frontend, backend]
        include:
          - component: frontend
            artifact_name: frontend-build
            artifact_path: dist/client
          - component: backend
            artifact_name: backend-build
            artifact_path: eb-bundle.zip
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: ${{ matrix.artifact_path }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      # Frontend deployment
      - name: Deploy frontend to S3
        if: matrix.component == 'frontend'
        run: |
          # Get S3 bucket name from CloudFormation stack outputs
          BUCKET_NAME=$(aws cloudformation describe-stacks \
            --stack-name findmylunch-qa \
            --query "Stacks[0].Outputs[?ExportName=='qa-FindMyLunch-WebsiteBucketName'].OutputValue" \
            --output text)
          
          aws s3 sync dist/client s3://$BUCKET_NAME --delete
          
          # Set appropriate cache-control headers for different file types
          echo "Setting cache-control headers..."
          aws s3 cp s3://$BUCKET_NAME s3://$BUCKET_NAME --recursive --exclude "*" --include "*.html" --metadata-directive REPLACE --cache-control "max-age=3600" --content-type "text/html"
          aws s3 cp s3://$BUCKET_NAME s3://$BUCKET_NAME --recursive --exclude "*" --include "*.css" --metadata-directive REPLACE --cache-control "max-age=86400" --content-type "text/css"
          aws s3 cp s3://$BUCKET_NAME s3://$BUCKET_NAME --recursive --exclude "*" --include "*.js" --metadata-directive REPLACE --cache-control "max-age=86400" --content-type "application/javascript"
          aws s3 cp s3://$BUCKET_NAME s3://$BUCKET_NAME --recursive --exclude "*" --include "*.jpg" --include "*.jpeg" --include "*.png" --include "*.gif" --metadata-directive REPLACE --cache-control "max-age=604800"

      - name: Invalidate CloudFront
        if: matrix.component == 'frontend'
        run: |
          # Get CloudFront distribution ID from CloudFormation stack outputs
          DISTRIBUTION_ID=$(aws cloudformation describe-stacks \
            --stack-name findmylunch-qa \
            --query "Stacks[0].Outputs[?ExportName=='qa-FindMyLunch-CloudFrontDistributionId'].OutputValue" \
            --output text)
          
          aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID --paths "/*"

      # Backend deployment
      - name: Deploy backend to Elastic Beanstalk
        if: matrix.component == 'backend'
        uses: einaregilsson/beanstalk-deploy@v21
        with:
          aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          application_name: ${{ secrets.EB_APPLICATION_NAME }}
          environment_name: ${{ secrets.EB_ENVIRONMENT_NAME }}
          version_label: "findmylunch-backend-${{ github.run_number }}-${{ github.run_attempt }}"
          region: ${{ vars.AWS_REGION }}
          deployment_package: eb-bundle.zip
          wait_for_environment_recovery: 300

   approve-prod-deployment:
    name: Approve Production Deployment
    needs: build
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod'
    runs-on: ubuntu-latest
    environment: 
      name: prod-approval
    steps:
      - name: Approval notification
        run: echo "Production deployment has been approved"

   deploy-prod:
    name: Deploy to Production
    needs:
      - build 
      - approve-prod-deployment
    runs-on: ubuntu-latest
    environment: prod
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod'
    strategy:
      matrix:
        component: [frontend, backend]
        include:
          - component: frontend
            artifact_name: frontend-build
            artifact_path: dist/client
          - component: backend
            artifact_name: backend-build
            artifact_path: eb-bundle.zip
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: ${{ matrix.artifact_path }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      # Frontend deployment
      - name: Deploy frontend to S3
        if: matrix.component == 'frontend'
        run: |
          # Get S3 bucket name from CloudFormation stack outputs
          BUCKET_NAME=$(aws cloudformation describe-stacks \
            --stack-name findmylunch-prod \
            --query "Stacks[0].Outputs[?ExportName=='prod-FindMyLunch-WebsiteBucketName'].OutputValue" \
            --output text)
          
          aws s3 sync dist/client s3://$BUCKET_NAME --delete
          
          # Set appropriate cache-control headers for different file types
          echo "Setting cache-control headers..."
          aws s3 cp s3://$BUCKET_NAME s3://$BUCKET_NAME --recursive --exclude "*" --include "*.html" --metadata-directive REPLACE --cache-control "max-age=3600" --content-type "text/html"
          aws s3 cp s3://$BUCKET_NAME s3://$BUCKET_NAME --recursive --exclude "*" --include "*.css" --metadata-directive REPLACE --cache-control "max-age=86400" --content-type "text/css"
          aws s3 cp s3://$BUCKET_NAME s3://$BUCKET_NAME --recursive --exclude "*" --include "*.js" --metadata-directive REPLACE --cache-control "max-age=86400" --content-type "application/javascript"
          aws s3 cp s3://$BUCKET_NAME s3://$BUCKET_NAME --recursive --exclude "*" --include "*.jpg" --include "*.jpeg" --include "*.png" --include "*.gif" --metadata-directive REPLACE --cache-control "max-age=604800"

      - name: Invalidate CloudFront
        if: matrix.component == 'frontend'
        run: |
          # Get CloudFront distribution ID from CloudFormation stack outputs
          DISTRIBUTION_ID=$(aws cloudformation describe-stacks \
            --stack-name findmylunch-prod \
            --query "Stacks[0].Outputs[?ExportName=='prod-FindMyLunch-CloudFrontDistributionId'].OutputValue" \
            --output text)
          
          aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID --paths "/*"

      # Backend deployment
      - name: Deploy backend to Elastic Beanstalk
        if: matrix.component == 'backend'
        uses: einaregilsson/beanstalk-deploy@v21
        with:
          aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          application_name: ${{ vars.EB_APPLICATION_NAME }}
          environment_name: ${{ vars.EB_ENVIRONMENT_NAME }}
          version_label: "findmylunch-backend-${{ github.run_number }}-${{ github.run_attempt }}"
          region: ${{ vars.AWS_REGION }}
          deployment_package: eb-bundle.zip
          wait_for_environment_recovery: 300